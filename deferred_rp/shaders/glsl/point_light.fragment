#include "fragmentHeader.h"
#include "uniformWorldConstants.h"
precision highp float;
#include "quadSwizzle.glsl"
#line 5


// Choose supported framebuffer color sampling extension.
#ifdef GL_EXT_shader_framebuffer_fetch
#define gl_LastFragColorARM finalColor
inout vec4 finalColor;
#else
out vec4 finalColor;
#endif


// Settings
const float specShine = 10.0;
const float specIntensity= 0.1;
const float fogIntensity = 0.02;

const float scatterDiffuse = 0.5;
const float scatterShine = 50.0;
const float scatterDensity = 0.3;
const float scatterThickness = 0.1;

const float ditherSpread = 20.0/255.0;

// 8x8 dithering matrix.
const float bayer8[64] = float[64](
-0.9688, 0.0312, -0.7188, 0.2812, -0.9062, 0.0938, -0.6562, 0.3438,
0.5312, -0.4688, 0.7812, -0.2188, 0.5938, -0.4062, 0.8438, -0.1562,
-0.5938, 0.4062, -0.8438, 0.1562, -0.5312, 0.4688, -0.7812, 0.2188,
0.9062, -0.0938, 0.6562, -0.3438, 0.9688, -0.0312, 0.7188, -0.2812,
-0.875, 0.125, -0.625, 0.375, -0.9375, 0.0625, -0.6875, 0.3125,
0.625, -0.375, 0.875, -0.125, 0.5625, -0.4375, 0.8125, -0.1875,
-0.5, 0.5, -0.75, 0.25, -0.5625, 0.4375, -0.8125, 0.1875,
1.0, 0.0, 0.75, -0.25, 0.9375, -0.0625, 0.6875, -0.3125
);


in highp vec4 color;
in highp vec3 position;
in highp vec3 origin;


float calcFogLight(float fragDist, vec3 dir) {
	float d = dot(dir, origin.xyz);
	vec3 orthLvec = origin.xyz - dir * d;
	
	float h = length(orthLvec);
	float oL = length(origin.xyz - orthLvec)*sign(d);

	return (atan((fragDist-oL)/h) - atan(-oL/h))/h;
}


void main()
{
	// Don't shade the sky in non-volumetric mode.
	#ifndef VOLUMETRIC_FOG
		float depth = gl_LastFragDepthARM;
		if (depth == 1.0) { discard; }
	#endif
	
	
	// Compute N, L and viewPos.
	#ifdef VOLUMETRIC_FOG
		float viewZ = PROJ[3][2] / ((gl_LastFragDepthARM * 2.0 - 1.0) + PROJ[2][2]);
	#else
		float viewZ = PROJ[3][2] / ((depth * 2.0 - 1.0) + PROJ[2][2]);
	#endif
	
	vec3 viewPos = viewZ * position / position.z;
	vec3 N = normalize(cross(dFdy(viewPos), dFdx(viewPos)));
	
	vec3 L = origin - viewPos;
	float dist = length(L);
	L /= dist;

	
	// Compute diffuse, scatter and early exit if dot < 0 for non-scattering materials.
	float diffuse = dot(N, L);
	bool scatter = (gl_LastFragStencilARM & 4) != 0;
	#ifndef VOLUMETRIC_FOG
		if (diffuse < 0.0 && !scatter) { discard; }
	#endif
	
	
	// Compute specular and attenuation.
	float viewLen = length(viewPos);
	vec3 viewVec = -viewPos/viewLen;
	
	vec3 h = normalize(L+viewVec);
	
	float specular = specIntensity*pow(max(dot(N, h), 0.0), specShine);
	float attenuation = 1.0/(dist*dist);
	
	
	// Unpack albedo and HDR color buffers.
	vec3 swizzlePos = quadSwizzlePos();
	
	vec3 col = gl_LastFragColorARM.rgb;
	
	vec3 col0 = quadSwizzle0(col, swizzlePos.x);
	vec3 col1 = quadSwizzle1(col, swizzlePos.x);
	vec3 col2 = quadSwizzle2(col, swizzlePos.yz);
	
	vec3 albedo = vec3(col0.b, col1.b, col2.b);
	albedo = mod(31.0*albedo, 16.0)/15.0;
	
	vec3 lighting = 2.0*vec3(col0.g, col1.g, col2.g) + 2.0*round(31.0*vec3(col0.r, col1.r, col2.r)/2.0);
	
	
	// Switch between + and - dithering based on the last albedo bit to prevent accumulation of artefacts.
	float ditherBit = float(col.b*31.0 >= 16.0);
	float dither = ditherSpread * (ditherBit-0.5) * bayer8[int(0.5*gl_FragCoord.x)%8 + 8*(int(0.5*gl_FragCoord.y)%8)];
	
	
	// Convert the sky to HDR if it hasn't been converted yet.
	float condition = (gl_LastFragDepthARM >= 1.0) && ((gl_LastFragStencilARM & 2) == 0) ? 1.0 : 0.0;
	albedo = mix(albedo, vec3(col0.r, col1.g, col2.b), vec3(quadSwizzle0(condition, swizzlePos.x), quadSwizzle1(condition, swizzlePos.x), quadSwizzle2(condition, swizzlePos.yz) ));
	lighting = mix(lighting, vec3(col0.r, col1.g, col2.b), vec3(quadSwizzle0(condition, swizzlePos.x), quadSwizzle1(condition, swizzlePos.x), quadSwizzle2(condition, swizzlePos.yz) ));
	
	
	// Compute scattering.
	vec3 sc = pow(max(dot(-viewVec, L), 0.0), scatterShine) * pow(albedo, vec3(scatterDensity*tan(acos( abs(diffuse) ))) + scatterThickness);

	
	// Add light source contribution to pixel's color.
#ifdef VOLUMETRIC_FOG
	float fog = fogIntensity*calcFogLight(viewLen, normalize(position.xyz));
	lighting += (attenuation * (float(scatter)*sc + (scatter && diffuse < 0.0 ? -scatterDiffuse : step(0.0, diffuse))*diffuse*albedo + step(0.0, diffuse)*specular) + fog) * 16.0*color.rgb;
#else
	lighting += attenuation * (float(scatter)*sc + (scatter && diffuse < 0.0 ? -scatterDiffuse : step(0.0, diffuse))*diffuse*albedo + step(0.0, diffuse)*specular) * 16.0*color.rgb;
#endif
	
	
	// Use lighting from a single fragment across the quad, to avoid chromatic artefacts.
	lighting = quadSwizzle0(lighting, swizzlePos.x);
	
	
	// Pack updated HDR color and albedo back into the framebuffer.
	vec3 hdrCol1 = mod(31.0*lighting, 64.0)/63.0+dither;
	vec3 hdrCol2 = 2.0*floor(31.0*lighting/64.0)/31.0;
	
	albedo = (15.0*albedo + (1.0-ditherBit)*16.0)/31.0;
	
	int index = quadSwizzleIndex(swizzlePos);
	
	finalColor = index == 0 ? vec4(hdrCol2.r, hdrCol1.r, albedo.r, 1.0) : index == 1 ? vec4(hdrCol2.g, hdrCol1.g, albedo.g, 1.0) : vec4(hdrCol2.b, hdrCol1.b, albedo.b, 1.0);
	
}
